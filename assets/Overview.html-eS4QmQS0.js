import{_ as s,c as a,d,e,a as l,f as r,b as n,r as i,o as p}from"./app-14iK3gD2.js";const T={};function O(u,t){const o=i("RouteLink");return p(),a("div",null,[t[56]||(t[56]=d("h1",{id:"运算符和函数",tabindex:"-1"},[d("a",{class:"header-anchor",href:"#运算符和函数"},[d("span",null,"运算符和函数")])],-1)),d("p",null,[t[1]||(t[1]=e("本章介绍 IoTDB 支持的运算符和函数。IoTDB 提供了丰富的内置运算符和函数来满足您的计算需求，同时支持通过")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/User-Defined-Function.html"},{default:r(()=>t[0]||(t[0]=[e("用户自定义函数")])),_:1}),t[2]||(t[2]=e("能力进行扩展。"))]),t[57]||(t[57]=d("p",null,[e("可以使用 "),d("code",null,"SHOW FUNCTIONS"),e(" 显示所有可用函数的列表，包括内置函数和自定义函数。")],-1)),d("p",null,[t[4]||(t[4]=e("关于运算符和函数在 SQL 中的行为，可以查看文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Query-Data/Select-Expression.html"},{default:r(()=>t[3]||(t[3]=[e("选择表达式")])),_:1}),t[5]||(t[5]=e("。"))]),t[58]||(t[58]=n('<h2 id="运算符列表" tabindex="-1"><a class="header-anchor" href="#运算符列表"><span>运算符列表</span></a></h2><h3 id="算数运算符" tabindex="-1"><a class="header-anchor" href="#算数运算符"><span>算数运算符</span></a></h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td><code>+</code></td><td>取正（单目）</td></tr><tr><td><code>-</code></td><td>取负（单目）</td></tr><tr><td><code>*</code></td><td>乘</td></tr><tr><td><code>/</code></td><td>除</td></tr><tr><td><code>%</code></td><td>取余</td></tr><tr><td><code>+</code></td><td>加</td></tr><tr><td><code>-</code></td><td>减</td></tr></tbody></table>',3)),d("p",null,[t[7]||(t[7]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Mathematical.html"},{default:r(()=>t[6]||(t[6]=[e("算数运算符和函数")])),_:1}),t[8]||(t[8]=e("。"))]),t[59]||(t[59]=n('<h3 id="比较运算符" tabindex="-1"><a class="header-anchor" href="#比较运算符"><span>比较运算符</span></a></h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td></tr><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>==</code></td><td>等于</td></tr><tr><td><code>!=</code> / <code>&lt;&gt;</code></td><td>不等于</td></tr><tr><td><code>BETWEEN ... AND ...</code></td><td>在指定范围内</td></tr><tr><td><code>NOT BETWEEN ... AND ...</code></td><td>不在指定范围内</td></tr><tr><td><code>LIKE</code></td><td>匹配简单模式</td></tr><tr><td><code>NOT LIKE</code></td><td>无法匹配简单模式</td></tr><tr><td><code>REGEXP</code></td><td>匹配正则表达式</td></tr><tr><td><code>NOT REGEXP</code></td><td>无法匹配正则表达式</td></tr><tr><td><code>IS NULL</code></td><td>是空值</td></tr><tr><td><code>IS NOT NULL</code></td><td>不是空值</td></tr><tr><td><code>IN</code> / <code>CONTAINS</code></td><td>是指定列表中的值</td></tr><tr><td><code>NOT IN</code> / <code>NOT CONTAINS</code></td><td>不是指定列表中的值</td></tr></tbody></table>',2)),d("p",null,[t[10]||(t[10]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Comparison.html"},{default:r(()=>t[9]||(t[9]=[e("比较运算符和函数")])),_:1}),t[11]||(t[11]=e("。"))]),t[60]||(t[60]=n('<h3 id="逻辑运算符" tabindex="-1"><a class="header-anchor" href="#逻辑运算符"><span>逻辑运算符</span></a></h3><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td><code>NOT</code> / <code>!</code></td><td>取非（单目）</td></tr><tr><td><code>AND</code> / <code>&amp;</code> / <code>&amp;&amp;</code></td><td>逻辑与</td></tr><tr><td><code>OR</code>/ | / ||</td><td>逻辑或</td></tr></tbody></table>',2)),d("p",null,[t[13]||(t[13]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Logical.html"},{default:r(()=>t[12]||(t[12]=[e("逻辑运算符")])),_:1}),t[14]||(t[14]=e("。"))]),t[61]||(t[61]=n(`<h3 id="运算符优先级" tabindex="-1"><a class="header-anchor" href="#运算符优先级"><span>运算符优先级</span></a></h3><p>运算符的优先级从高到低如下所示排列，同一行的运算符具有相同的优先级。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="background-color:#282c34;color:#abb2bf;"><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span style="color:#ABB2BF;">!, - (单目), + (单目)</span></span>
<span class="line"><span style="color:#ABB2BF;">*, /, DIV, %, MOD</span></span>
<span class="line"><span style="color:#ABB2BF;">-, +</span></span>
<span class="line"><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">, </span><span style="color:#56B6C2;">==</span><span style="color:#ABB2BF;">, </span><span style="color:#56B6C2;">&lt;=&gt;</span><span style="color:#ABB2BF;">, </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#ABB2BF;">, </span><span style="color:#56B6C2;">&gt;</span><span style="color:#ABB2BF;">, </span><span style="color:#56B6C2;">&lt;=</span><span style="color:#ABB2BF;">, </span><span style="color:#56B6C2;">&lt;</span><span style="color:#ABB2BF;">, </span><span style="color:#56B6C2;">&lt;&gt;</span><span style="color:#ABB2BF;">, </span><span style="color:#56B6C2;">!=</span></span>
<span class="line"><span style="color:#C678DD;">LIKE</span><span style="color:#ABB2BF;">, REGEXP, </span><span style="color:#C678DD;">NOT</span><span style="color:#C678DD;"> LIKE</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">NOT</span><span style="color:#ABB2BF;"> REGEXP</span></span>
<span class="line"><span style="color:#C678DD;">BETWEEN</span><span style="color:#ABB2BF;"> ... </span><span style="color:#C678DD;">AND</span><span style="color:#ABB2BF;"> ..., </span><span style="color:#C678DD;">NOT</span><span style="color:#C678DD;"> BETWEEN</span><span style="color:#ABB2BF;"> ... </span><span style="color:#C678DD;">AND</span><span style="color:#ABB2BF;"> ...</span></span>
<span class="line"><span style="color:#C678DD;">IS</span><span style="color:#C678DD;"> NULL</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">IS NOT NULL</span></span>
<span class="line"><span style="color:#C678DD;">IN</span><span style="color:#ABB2BF;">, CONTAINS, </span><span style="color:#C678DD;">NOT</span><span style="color:#C678DD;"> IN</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">NOT</span><span style="color:#ABB2BF;"> CONTAINS</span></span>
<span class="line"><span style="color:#C678DD;">AND</span><span style="color:#ABB2BF;">, &amp;, &amp;&amp;</span></span>
<span class="line"><span style="color:#C678DD;">OR</span><span style="color:#ABB2BF;">, |, ||</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="内置函数列表" tabindex="-1"><a class="header-anchor" href="#内置函数列表"><span>内置函数列表</span></a></h2><p>列表中的函数无须注册即可在 IoTDB 中使用，数据函数质量库中的函数需要参考注册步骤进行注册后才能使用。</p><h3 id="聚合函数" tabindex="-1"><a class="header-anchor" href="#聚合函数"><span>聚合函数</span></a></h3>`,6)),d("table",null,[t[31]||(t[31]=d("thead",null,[d("tr",null,[d("th",null,"函数名"),d("th",null,"功能描述"),d("th",null,"允许的输入类型"),d("th",null,"输出类型")])],-1)),d("tbody",null,[t[21]||(t[21]=d("tr",null,[d("td",null,"SUM"),d("td",null,"求和。"),d("td",null,"INT32 INT64 FLOAT DOUBLE"),d("td",null,"DOUBLE")],-1)),t[22]||(t[22]=d("tr",null,[d("td",null,"COUNT"),d("td",null,"计算数据点数。"),d("td",null,"所有类型"),d("td",null,"INT")],-1)),t[23]||(t[23]=d("tr",null,[d("td",null,"AVG"),d("td",null,"求平均值。"),d("td",null,"INT32 INT64 FLOAT DOUBLE"),d("td",null,"DOUBLE")],-1)),t[24]||(t[24]=d("tr",null,[d("td",null,"EXTREME"),d("td",null,"求具有最大绝对值的值。如果正值和负值的最大绝对值相等，则返回正值。"),d("td",null,"INT32 INT64 FLOAT DOUBLE"),d("td",null,"与输入类型一致")],-1)),t[25]||(t[25]=d("tr",null,[d("td",null,"MAX_VALUE"),d("td",null,"求最大值。"),d("td",null,"INT32 INT64 FLOAT DOUBLE"),d("td",null,"与输入类型一致")],-1)),t[26]||(t[26]=d("tr",null,[d("td",null,"MIN_VALUE"),d("td",null,"求最小值。"),d("td",null,"INT32 INT64 FLOAT DOUBLE"),d("td",null,"与输入类型一致")],-1)),t[27]||(t[27]=d("tr",null,[d("td",null,"FIRST_VALUE"),d("td",null,"求时间戳最小的值。"),d("td",null,"所有类型"),d("td",null,"与输入类型一致")],-1)),t[28]||(t[28]=d("tr",null,[d("td",null,"LAST_VALUE"),d("td",null,"求时间戳最大的值。"),d("td",null,"所有类型"),d("td",null,"与输入类型一致")],-1)),t[29]||(t[29]=d("tr",null,[d("td",null,"MAX_TIME"),d("td",null,"求最大时间戳。"),d("td",null,"所有类型"),d("td",null,"Timestamp")],-1)),t[30]||(t[30]=d("tr",null,[d("td",null,"MIN_TIME"),d("td",null,"求最小时间戳。"),d("td",null,"所有类型"),d("td",null,"Timestamp")],-1)),d("tr",null,[d("td",null,[t[16]||(t[16]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Aggregation.html"},{default:r(()=>t[15]||(t[15]=[e("聚合函数")])),_:1}),t[17]||(t[17]=e("。"))]),t[18]||(t[18]=d("td",null,null,-1)),t[19]||(t[19]=d("td",null,null,-1)),t[20]||(t[20]=d("td",null,null,-1))])])]),t[62]||(t[62]=n('<h3 id="数学函数" tabindex="-1"><a class="header-anchor" href="#数学函数"><span>数学函数</span></a></h3><table><thead><tr><th>函数名</th><th>输入序列类型</th><th>输出序列类型</th><th>Java 标准库中的对应实现</th></tr></thead><tbody><tr><td>SIN</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#sin(double)</td></tr><tr><td>COS</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#cos(double)</td></tr><tr><td>TAN</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#tan(double)</td></tr><tr><td>ASIN</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#asin(double)</td></tr><tr><td>ACOS</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#acos(double)</td></tr><tr><td>ATAN</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#atan(double)</td></tr><tr><td>SINH</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#sinh(double)</td></tr><tr><td>COSH</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#cosh(double)</td></tr><tr><td>TANH</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#tanh(double)</td></tr><tr><td>DEGREES</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#toDegrees(double)</td></tr><tr><td>RADIANS</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#toRadians(double)</td></tr><tr><td>ABS</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>与输入序列的实际类型一致</td><td>Math#abs(int) / Math#abs(long) /Math#abs(float) /Math#abs(double)</td></tr><tr><td>SIGN</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#signum(double)</td></tr><tr><td>CEIL</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#ceil(double)</td></tr><tr><td>FLOOR</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#floor(double)</td></tr><tr><td>ROUND</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#rint(double)</td></tr><tr><td>EXP</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#exp(double)</td></tr><tr><td>LN</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#log(double)</td></tr><tr><td>LOG10</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#log10(double)</td></tr><tr><td>SQRT</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>Math#sqrt(double)</td></tr></tbody></table>',2)),d("p",null,[t[33]||(t[33]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Mathematical.html"},{default:r(()=>t[32]||(t[32]=[e("算数运算符和函数")])),_:1}),t[34]||(t[34]=e("。"))]),t[63]||(t[63]=n('<h3 id="比较函数" tabindex="-1"><a class="header-anchor" href="#比较函数"><span>比较函数</span></a></h3><table><thead><tr><th>函数名</th><th>可接收的输入序列类型</th><th>必要的属性参数</th><th>输出序列类型</th><th>功能类型</th></tr></thead><tbody><tr><td>ON_OFF</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td><code>threshold</code>:DOUBLE</td><td>BOOLEAN</td><td>返回<code>ts_value &gt;= threshold</code>的bool值</td></tr><tr><td>IN_RANGE</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td><code>lower</code>:DOUBLE<br><code>upper</code>:DOUBLE</td><td>BOOLEAN</td><td>返回<code>ts_value &gt;= lower &amp;&amp; ts_value &lt;= upper</code>的bool值</td></tr></tbody></table>',2)),d("p",null,[t[36]||(t[36]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Comparison.html"},{default:r(()=>t[35]||(t[35]=[e("比较运算符和函数")])),_:1}),t[37]||(t[37]=e("。"))]),t[64]||(t[64]=n('<h3 id="字符串处理函数" tabindex="-1"><a class="header-anchor" href="#字符串处理函数"><span>字符串处理函数</span></a></h3><table><thead><tr><th>函数名</th><th>输入序列类型</th><th>必要的属性参数</th><th>输出序列类型</th><th>功能描述</th></tr></thead><tbody><tr><td>STRING_CONTAINS</td><td>TEXT</td><td><code>s</code>: 待搜寻的字符串</td><td>BOOLEAN</td><td>判断字符串中是否存在<code>s</code></td></tr><tr><td>STRING_MATCHES</td><td>TEXT</td><td><code>regex</code>: Java 标准库风格的正则表达式</td><td>BOOLEAN</td><td>判断字符串是否能够被正则表达式<code>regex</code>匹配</td></tr><tr><td>LENGTH</td><td>TEXT</td><td>无</td><td>INT32</td><td>返回字符串的长度</td></tr><tr><td>LOCATE</td><td>TEXT</td><td><code>target</code>: 需要被定位的子串 <br> <code>reverse</code>: 指定是否需要倒序定位，默认值为<code>false</code>, 即从左至右定位</td><td>INT32</td><td>获取<code>target</code>子串第一次出现在输入序列的位置，如果输入序列中不包含<code>target</code>则返回 -1</td></tr><tr><td>STARTSWITH</td><td>TEXT</td><td><code>target</code>: 需要匹配的前缀</td><td>BOOLEAN</td><td>判断字符串是否有指定前缀</td></tr><tr><td>ENDSWITH</td><td>TEXT</td><td><code>target</code>: 需要匹配的后缀</td><td>BOOLEAN</td><td>判断字符串是否有指定后缀</td></tr><tr><td>CONCAT</td><td>TEXT</td><td><code>targets</code>: 一系列 K-V, key需要以<code>target</code>为前缀且不重复, value是待拼接的字符串。<br><code>series_behind</code>: 指定拼接时时间序列是否在后面，默认为<code>false</code>。</td><td>TEXT</td><td>拼接字符串和<code>target</code>字串</td></tr><tr><td>SUBSTR</td><td>TEXT</td><td><code>start</code>: 指定子串开始下标 <br><code>end</code>: 指定子串结束下标</td><td>TEXT</td><td>获取下标从<code>start</code>到<code>end - 1</code>的子串</td></tr><tr><td>UPPER</td><td>TEXT</td><td>无</td><td>TEXT</td><td>将字符串转化为大写</td></tr><tr><td>LOWER</td><td>TEXT</td><td>无</td><td>TEXT</td><td>将字符串转化为小写</td></tr><tr><td>TRIM</td><td>TEXT</td><td>无</td><td>TEXT</td><td>移除字符串前后的空格</td></tr><tr><td>STRCMP</td><td>TEXT</td><td>无</td><td>TEXT</td><td>用于比较两个输入序列，如果值相同返回 <code>0</code> , 序列1的值小于序列2的值返回一个<code>负数</code>，序列1的值大于序列2的值返回一个<code>正数</code></td></tr></tbody></table>',2)),d("p",null,[t[39]||(t[39]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/String.html"},{default:r(()=>t[38]||(t[38]=[e("字符串处理函数")])),_:1}),t[40]||(t[40]=e("。"))]),t[65]||(t[65]=n('<h3 id="数据类型转换函数" tabindex="-1"><a class="header-anchor" href="#数据类型转换函数"><span>数据类型转换函数</span></a></h3><table><thead><tr><th>函数名</th><th>必要的属性参数</th><th>输出序列类型</th><th>功能类型</th></tr></thead><tbody><tr><td>CAST</td><td><code>type</code>:输出的数据点的类型，只能是 INT32 / INT64 / FLOAT / DOUBLE / BOOLEAN / TEXT</td><td>由输入属性参数<code>type</code>决定</td><td>将数据转换为<code>type</code>参数指定的类型。</td></tr></tbody></table>',2)),d("p",null,[t[42]||(t[42]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Conversion.html"},{default:r(()=>t[41]||(t[41]=[e("数据类型转换")])),_:1}),t[43]||(t[43]=e("。"))]),t[66]||(t[66]=n('<h3 id="常序列生成函数" tabindex="-1"><a class="header-anchor" href="#常序列生成函数"><span>常序列生成函数</span></a></h3><table><thead><tr><th>函数名</th><th>必要的属性参数</th><th>输出序列类型</th><th>功能描述</th></tr></thead><tbody><tr><td>CONST</td><td><code>value</code>: 输出的数据点的值 <br><code>type</code>: 输出的数据点的类型，只能是 INT32 / INT64 / FLOAT / DOUBLE / BOOLEAN / TEXT</td><td>由输入属性参数 <code>type</code> 决定</td><td>根据输入属性 <code>value</code> 和 <code>type</code> 输出用户指定的常序列。</td></tr><tr><td>PI</td><td>无</td><td>DOUBLE</td><td>常序列的值：<code>π</code> 的 <code>double</code> 值，圆的周长与其直径的比值，即圆周率，等于 <em>Java标准库</em> 中的<code>Math.PI</code>。</td></tr><tr><td>E</td><td>无</td><td>DOUBLE</td><td>常序列的值：<code>e</code> 的 <code>double</code> 值，自然对数的底，它等于 <em>Java 标准库</em> 中的 <code>Math.E</code>。</td></tr></tbody></table>',2)),d("p",null,[t[45]||(t[45]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Constant.html"},{default:r(()=>t[44]||(t[44]=[e("常序列生成函数")])),_:1}),t[46]||(t[46]=e("。"))]),t[67]||(t[67]=n('<h3 id="选择函数" tabindex="-1"><a class="header-anchor" href="#选择函数"><span>选择函数</span></a></h3><table><thead><tr><th>函数名</th><th>输入序列类型</th><th>必要的属性参数</th><th>输出序列类型</th><th>功能描述</th></tr></thead><tbody><tr><td>TOP_K</td><td>INT32 / INT64 / FLOAT / DOUBLE / TEXT</td><td><code>k</code>: 最多选择的数据点数，必须大于 0 小于等于 1000</td><td>与输入序列的实际类型一致</td><td>返回某时间序列中值最大的<code>k</code>个数据点。若多于<code>k</code>个数据点的值并列最大，则返回时间戳最小的数据点。</td></tr><tr><td>BOTTOM_K</td><td>INT32 / INT64 / FLOAT / DOUBLE / TEXT</td><td><code>k</code>: 最多选择的数据点数，必须大于 0 小于等于 1000</td><td>与输入序列的实际类型一致</td><td>返回某时间序列中值最小的<code>k</code>个数据点。若多于<code>k</code>个数据点的值并列最小，则返回时间戳最小的数据点。</td></tr></tbody></table>',2)),d("p",null,[t[48]||(t[48]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Selection.html"},{default:r(()=>t[47]||(t[47]=[e("选择函数")])),_:1}),t[49]||(t[49]=e("。"))]),t[68]||(t[68]=n('<h3 id="区间查询函数" tabindex="-1"><a class="header-anchor" href="#区间查询函数"><span>区间查询函数</span></a></h3><table><thead><tr><th>函数名</th><th>输入序列类型</th><th>属性参数</th><th>输出序列类型</th><th>功能描述</th></tr></thead><tbody><tr><td>ZERO_DURATION</td><td>INT32/ INT64/ FLOAT/ DOUBLE/ BOOLEAN</td><td><code>min</code>:可选，默认值0<br><code>max</code>:可选，默认值<code>Long.MAX_VALUE</code></td><td>Long</td><td>返回时间序列连续为0(false)的开始时间与持续时间，持续时间t(单位ms)满足<code>t &gt;= min &amp;&amp; t &lt;= max</code></td></tr><tr><td>NON_ZERO_DURATION</td><td>INT32/ INT64/ FLOAT/ DOUBLE/ BOOLEAN</td><td><code>min</code>:可选，默认值0<br><code>max</code>:可选，默认值<code>Long.MAX_VALUE</code></td><td>Long</td><td>返回时间序列连续不为0(false)的开始时间与持续时间，持续时间t(单位ms)满足<code>t &gt;= min &amp;&amp; t &lt;= max</code></td></tr><tr><td>ZERO_COUNT</td><td>INT32/ INT64/ FLOAT/ DOUBLE/ BOOLEAN</td><td><code>min</code>:可选，默认值1<br><code>max</code>:可选，默认值<code>Long.MAX_VALUE</code></td><td>Long</td><td>返回时间序列连续为0(false)的开始时间与其后数据点的个数，数据点个数n满足<code>n &gt;= min &amp;&amp; n &lt;= max</code></td></tr><tr><td>NON_ZERO_COUNT</td><td>INT32/ INT64/ FLOAT/ DOUBLE/ BOOLEAN</td><td><code>min</code>:可选，默认值1<br><code>max</code>:可选，默认值<code>Long.MAX_VALUE</code></td><td>Long</td><td>返回时间序列连续不为0(false)的开始时间与其后数据点的个数，数据点个数n满足<code>n &gt;= min &amp;&amp; n &lt;= max</code></td></tr></tbody></table>',2)),d("p",null,[t[51]||(t[51]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Continuous-Interval.html"},{default:r(()=>t[50]||(t[50]=[e("区间查询函数")])),_:1}),t[52]||(t[52]=e("。"))]),t[69]||(t[69]=n('<h3 id="趋势计算函数" tabindex="-1"><a class="header-anchor" href="#趋势计算函数"><span>趋势计算函数</span></a></h3><table><thead><tr><th>函数名</th><th>输入序列类型</th><th>输出序列类型</th><th>功能描述</th></tr></thead><tbody><tr><td>TIME_DIFFERENCE</td><td>INT32 / INT64 / FLOAT / DOUBLE / BOOLEAN / TEXT</td><td>INT64</td><td>统计序列中某数据点的时间戳与前一数据点时间戳的差。范围内第一个数据点没有对应的结果输出。</td></tr><tr><td>DIFFERENCE</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>与输入序列的实际类型一致</td><td>统计序列中某数据点的值与前一数据点的值的差。范围内第一个数据点没有对应的结果输出。</td></tr><tr><td>NON_NEGATIVE_DIFFERENCE</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>与输入序列的实际类型一致</td><td>统计序列中某数据点的值与前一数据点的值的差的绝对值。范围内第一个数据点没有对应的结果输出。</td></tr><tr><td>DERIVATIVE</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>统计序列中某数据点相对于前一数据点的变化率，数量上等同于 DIFFERENCE / TIME_DIFFERENCE。范围内第一个数据点没有对应的结果输出。</td></tr><tr><td>NON_NEGATIVE_DERIVATIVE</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>DOUBLE</td><td>统计序列中某数据点相对于前一数据点的变化率的绝对值，数量上等同于 NON_NEGATIVE_DIFFERENCE / TIME_DIFFERENCE。范围内第一个数据点没有对应的结果输出。</td></tr></tbody></table><table><thead><tr><th>函数名</th><th>输入序列类型</th><th>参数</th><th>输出序列类型</th><th>功能描述</th></tr></thead><tbody><tr><td>DIFF</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td><code>ignoreNull</code>：可选，默认为true；为true时，前一个数据点值为null时，忽略该数据点继续向前找到第一个出现的不为null的值；为false时，如果前一个数据点为null，则不忽略，使用null进行相减，结果也为null</td><td>DOUBLE</td><td>统计序列中某数据点的值与前一数据点的值的差。第一个数据点没有对应的结果输出，输出值为null</td></tr></tbody></table>',3)),d("p",null,[t[54]||(t[54]=e("详细说明及示例见文档 ")),l(o,{to:"/zh/UserGuide/V1.1.x/Operators-Functions/Variation-Trend.html"},{default:r(()=>t[53]||(t[53]=[e("趋势计算函数")])),_:1}),t[55]||(t[55]=e("。"))]),t[70]||(t[70]=n('<h3 id="采样函数" tabindex="-1"><a class="header-anchor" href="#采样函数"><span>采样函数</span></a></h3><table><thead><tr><th>函数名</th><th>可接收的输入序列类型</th><th>必要的属性参数</th><th>输出序列类型</th><th>功能类型</th></tr></thead><tbody><tr><td>EQUAL_SIZE_BUCKET_RANDOM_SAMPLE</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>降采样比例 <code>proportion</code>，取值范围为<code>(0, 1]</code>，默认为<code>0.1</code></td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>返回符合采样比例的等分桶随机采样</td></tr><tr><td>EQUAL_SIZE_BUCKET_AGG_SAMPLE</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td><code>proportion</code>取值范围为<code>(0, 1]</code>，默认为<code>0.1</code><br><code>type</code>:取值类型有<code>avg</code>, <code>max</code>, <code>min</code>, <code>sum</code>, <code>extreme</code>, <code>variance</code>, 默认为<code>avg</code></td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>返回符合采样比例的等分桶聚合采样</td></tr><tr><td>EQUAL_SIZE_BUCKET_M4_SAMPLE</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td><code>proportion</code>取值范围为<code>(0, 1]</code>，默认为<code>0.1</code></td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>返回符合采样比例的等分桶M4采样</td></tr><tr><td>EQUAL_SIZE_BUCKET_OUTLIER_SAMPLE</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td><code>proportion</code>取值范围为<code>(0, 1]</code>，默认为<code>0.1</code><br><code>type</code>取值为<code>avg</code>或<code>stendis</code>或<code>cos</code>或<code>prenextdis</code>，默认为<code>avg</code><br><code>number</code>取值应大于0，默认<code>3</code></td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>返回符合采样比例和桶内采样个数的等分桶离群值采样</td></tr><tr><td>M4</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>包含固定点数的窗口和滑动时间窗口使用不同的属性参数。包含固定点数的窗口使用属性<code>windowSize</code>和<code>slidingStep</code>。滑动时间窗口使用属性<code>timeInterval</code>、<code>slidingStep</code>、<code>displayWindowBegin</code>和<code>displayWindowEnd</code>。更多细节见下文。</td><td>INT32 / INT64 / FLOAT / DOUBLE</td><td>返回每个窗口内的第一个点（<code>first</code>）、最后一个点（<code>last</code>）、最小值点（<code>bottom</code>）、最大值点（<code>top</code>）。在一个窗口内的聚合点输出之前，M4会将它们按照时间戳递增排序并且去重。</td></tr></tbody></table><h2 id="数据质量函数库" tabindex="-1"><a class="header-anchor" href="#数据质量函数库"><span>数据质量函数库</span></a></h2><p>对基于时序数据的应用而言，数据质量至关重要。基于用户自定义函数能力，IoTDB 提供了一系列关于数据质量的函数，包括数据画像、数据质量评估与修复等，能够满足工业领域对数据质量的需求。</p><p><strong>该函数库中的函数不是内置函数，使用前要先加载到系统中。</strong> 操作流程如下：</p><ol><li>下载包含全部依赖的 jar 包和注册脚本 <a href="https://archive.apache.org/dist/iotdb/1.0.1/apache-iotdb-1.0.1-library-udf-bin.zip" target="_blank" rel="noopener noreferrer">【点击下载】</a> ；</li><li>将 jar 包复制到 IoTDB 程序目录的 <code>ext\\udf</code> 目录下 (若您使用的是集群，请将jar包复制到所有DataNode的该目录下)；</li><li>启动 IoTDB；</li><li>将注册脚本复制到 IoTDB 的程序目录下（与<code>sbin</code>目录同级的根目录下），修改脚本中的参数（如果需要）并运行注册脚本以注册 UDF。</li></ol>',6))])}const N=s(T,[["render",O],["__file","Overview.html.vue"]]),c=JSON.parse('{"path":"/zh/UserGuide/V1.1.x/Operators-Functions/Overview.html","title":"运算符和函数","lang":"zh-CN","frontmatter":{"description":"运算符和函数 本章介绍 IoTDB 支持的运算符和函数。IoTDB 提供了丰富的内置运算符和函数来满足您的计算需求，同时支持通过能力进行扩展。 可以使用 SHOW FUNCTIONS 显示所有可用函数的列表，包括内置函数和自定义函数。 关于运算符和函数在 SQL 中的行为，可以查看文档 。 运算符列表 算数运算符 详细说明及示例见文档 。 比较运算符 ...","head":[["link",{"rel":"alternate","hreflang":"en-us","href":"https://iotdb.apache.org/UserGuide/V1.1.x/Operators-Functions/Overview.html"}],["meta",{"property":"og:url","content":"https://iotdb.apache.org/zh/UserGuide/V1.1.x/Operators-Functions/Overview.html"}],["meta",{"property":"og:site_name","content":"IoTDB Website"}],["meta",{"property":"og:title","content":"运算符和函数"}],["meta",{"property":"og:description","content":"运算符和函数 本章介绍 IoTDB 支持的运算符和函数。IoTDB 提供了丰富的内置运算符和函数来满足您的计算需求，同时支持通过能力进行扩展。 可以使用 SHOW FUNCTIONS 显示所有可用函数的列表，包括内置函数和自定义函数。 关于运算符和函数在 SQL 中的行为，可以查看文档 。 运算符列表 算数运算符 详细说明及示例见文档 。 比较运算符 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-07-10T03:11:17.000Z"}],["meta",{"property":"article:modified_time","content":"2023-07-10T03:11:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"运算符和函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-10T03:11:17.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"运算符列表","slug":"运算符列表","link":"#运算符列表","children":[{"level":3,"title":"算数运算符","slug":"算数运算符","link":"#算数运算符","children":[]},{"level":3,"title":"比较运算符","slug":"比较运算符","link":"#比较运算符","children":[]},{"level":3,"title":"逻辑运算符","slug":"逻辑运算符","link":"#逻辑运算符","children":[]},{"level":3,"title":"运算符优先级","slug":"运算符优先级","link":"#运算符优先级","children":[]}]},{"level":2,"title":"内置函数列表","slug":"内置函数列表","link":"#内置函数列表","children":[{"level":3,"title":"聚合函数","slug":"聚合函数","link":"#聚合函数","children":[]},{"level":3,"title":"数学函数","slug":"数学函数","link":"#数学函数","children":[]},{"level":3,"title":"比较函数","slug":"比较函数","link":"#比较函数","children":[]},{"level":3,"title":"字符串处理函数","slug":"字符串处理函数","link":"#字符串处理函数","children":[]},{"level":3,"title":"数据类型转换函数","slug":"数据类型转换函数","link":"#数据类型转换函数","children":[]},{"level":3,"title":"常序列生成函数","slug":"常序列生成函数","link":"#常序列生成函数","children":[]},{"level":3,"title":"选择函数","slug":"选择函数","link":"#选择函数","children":[]},{"level":3,"title":"区间查询函数","slug":"区间查询函数","link":"#区间查询函数","children":[]},{"level":3,"title":"趋势计算函数","slug":"趋势计算函数","link":"#趋势计算函数","children":[]},{"level":3,"title":"采样函数","slug":"采样函数","link":"#采样函数","children":[]}]},{"level":2,"title":"数据质量函数库","slug":"数据质量函数库","link":"#数据质量函数库","children":[]}],"git":{"createdTime":1688958677000,"updatedTime":1688958677000,"contributors":[{"name":"CritasWang","username":"CritasWang","email":"critas@outlook.com","commits":1,"url":"https://github.com/CritasWang"}]},"readingTime":{"minutes":11.8,"words":3541},"filePathRelative":"zh/UserGuide/V1.1.x/Operators-Functions/Overview.md","localizedDate":"2023年7月10日","autoDesc":true}');export{N as comp,c as data};
