import{_ as t,c as a,b as i,o as n}from"./app-DmvF8OAs.js";const r={};function o(s,e){return n(),a("div",null,e[0]||(e[0]=[i('<h1 id="数据分区与负载均衡" tabindex="-1"><a class="header-anchor" href="#数据分区与负载均衡"><span>数据分区与负载均衡</span></a></h1><p>IoTDB 以数据分区（DataRegion）为单位对元数据和数据进行管理，从序列和时间两个维度进行数据划分。</p><img style="width:100%;max-width:800px;max-height:600px;margin-left:auto;margin-right:auto;display:block;" src="https://alioss.timecho.com/docs/img/分区槽与数据分区.png?raw=true"><h2 id="分区槽" tabindex="-1"><a class="header-anchor" href="#分区槽"><span>分区槽</span></a></h2><p>一个序列分区槽和一个时间分区槽可以组合产生一个数据分区(当该序列分区槽在该时间分区槽下有对应数据时)。</p><h3 id="序列分区槽" tabindex="-1"><a class="header-anchor" href="#序列分区槽"><span>序列分区槽</span></a></h3><p>每个数据库持有固定数量的序列分区槽，默认为1000个。该数据库管理的每个时间序列都将通过序列分区算法（通常为某种哈希算法）被分配给唯一的序列分区槽管理。</p><img style="width:100%;max-width:800px;max-height:600px;margin-left:auto;margin-right:auto;display:block;" src="https://alioss.timecho.com/docs/img/SeriesPartitionSlot.png?raw=true"><h3 id="时间分区槽" tabindex="-1"><a class="header-anchor" href="#时间分区槽"><span>时间分区槽</span></a></h3><p>每个时间序列都将持续产生数据，如果一个时间序列产生的全部数据持续存储于一个节点，那么集群新增的 DataNode 可能无法得到有效利用。</p><p>时间分区槽从时间维度对时序数据进行分片（默认为每 7 天一个时间分区），使得集群时序数据的存储易于规划。</p><h2 id="元数据分区" tabindex="-1"><a class="header-anchor" href="#元数据分区"><span>元数据分区</span></a></h2><p>单个数据库的元数据分区管理，会按照一定的负载均衡策略，将所有序列槽分配到相应的 SchemaRegionGroup 中，进而在集群中横向扩展。</p><img style="width:100%;max-width:800px;max-height:600px;margin-left:auto;margin-right:auto;display:block;" src="https://alioss.timecho.com/docs/img/SchemaRegion.png?raw=true"><h2 id="数据分区" tabindex="-1"><a class="header-anchor" href="#数据分区"><span>数据分区</span></a></h2><p>会按照一定的负载均衡策略，进行时间分区槽和序列分区槽的划分，并分配到相应的 DataRegionGroup 中，进而在集群中横向扩展。</p><img style="width:100%;max-width:800px;max-height:600px;margin-left:auto;margin-right:auto;display:block;" src="https://alioss.timecho.com/docs/img/DataRegion.png?raw=true"><h2 id="负载均衡" tabindex="-1"><a class="header-anchor" href="#负载均衡"><span>负载均衡</span></a></h2><p>当集群容量保持不变时，数据会被均匀分配到各个节点，以实现存储和计算资源的均衡利用。</p><p>同时，在进行集群扩容时，系统会自动增加区域（region）的数量，以充分利用所有节点的计算资源，无需人工干预。这种动态扩展能够提高集群的性能和可扩展性，使整个系统更加灵活和高效。</p>',20)]))}const h=t(r,[["render",o],["__file","Cluster-data-partitioning.html.vue"]]),p=JSON.parse('{"path":"/zh/UserGuide/V1.2.x/Basic-Concept/Cluster-data-partitioning.html","title":"数据分区与负载均衡","lang":"zh-CN","frontmatter":{"description":"数据分区与负载均衡 IoTDB 以数据分区（DataRegion）为单位对元数据和数据进行管理，从序列和时间两个维度进行数据划分。 分区槽 一个序列分区槽和一个时间分区槽可以组合产生一个数据分区(当该序列分区槽在该时间分区槽下有对应数据时)。 序列分区槽 每个数据库持有固定数量的序列分区槽，默认为1000个。该数据库管理的每个时间序列都将通过序列分区算...","head":[["link",{"rel":"alternate","hreflang":"en-us","href":"https://iotdb.apache.org/UserGuide/V1.2.x/Basic-Concept/Cluster-data-partitioning.html"}],["meta",{"property":"og:url","content":"https://iotdb.apache.org/zh/UserGuide/V1.2.x/Basic-Concept/Cluster-data-partitioning.html"}],["meta",{"property":"og:site_name","content":"IoTDB Website"}],["meta",{"property":"og:title","content":"数据分区与负载均衡"}],["meta",{"property":"og:description","content":"数据分区与负载均衡 IoTDB 以数据分区（DataRegion）为单位对元数据和数据进行管理，从序列和时间两个维度进行数据划分。 分区槽 一个序列分区槽和一个时间分区槽可以组合产生一个数据分区(当该序列分区槽在该时间分区槽下有对应数据时)。 序列分区槽 每个数据库持有固定数量的序列分区槽，默认为1000个。该数据库管理的每个时间序列都将通过序列分区算..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-09-03T06:20:13.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-03T06:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据分区与负载均衡\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-03T06:20:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"分区槽","slug":"分区槽","link":"#分区槽","children":[{"level":3,"title":"序列分区槽","slug":"序列分区槽","link":"#序列分区槽","children":[]},{"level":3,"title":"时间分区槽","slug":"时间分区槽","link":"#时间分区槽","children":[]}]},{"level":2,"title":"元数据分区","slug":"元数据分区","link":"#元数据分区","children":[]},{"level":2,"title":"数据分区","slug":"数据分区","link":"#数据分区","children":[]},{"level":2,"title":"负载均衡","slug":"负载均衡","link":"#负载均衡","children":[]}],"git":{"createdTime":1691808532000,"updatedTime":1725344413000,"contributors":[{"name":"石林松","username":"石林松","email":"50943998+shi10lin0s@users.noreply.github.com","commits":1,"url":"https://github.com/石林松"},{"name":"wanghui42","username":"wanghui42","email":"105700158+wanghui42@users.noreply.github.com","commits":1,"url":"https://github.com/wanghui42"},{"name":"Li Yu Heng","username":"Li Yu Heng","email":"liyuheng55555@126.com","commits":2,"url":"https://github.com/Li Yu Heng"}]},"readingTime":{"minutes":2.43,"words":729},"filePathRelative":"zh/UserGuide/V1.2.x/Basic-Concept/Cluster-data-partitioning.md","localizedDate":"2023年8月12日","autoDesc":true}');export{h as comp,p as data};
