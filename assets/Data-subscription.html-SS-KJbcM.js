import{_ as i,c as a,b as t,d as l,e as s,a as o,w as r,r as c,o as d}from"./app-CipiMN0H.js";const p={};function u(m,e){const n=c("RouteLink");return d(),a("div",null,[e[3]||(e[3]=t(`<h1 id="data-subscription" tabindex="-1"><a class="header-anchor" href="#data-subscription"><span>Data Subscription</span></a></h1><h2 id="_1-feature-introduction" tabindex="-1"><a class="header-anchor" href="#_1-feature-introduction"><span>1. Feature Introduction</span></a></h2><p>The IoTDB data subscription module (also known as the IoTDB subscription client) is a feature supported after IoTDB V1.3.3, which provides users with a streaming data consumption method that is different from data queries. It refers to the basic concepts and logic of message queue products such as Kafka, <strong>providing data subscription and consumption interfaces</strong>, but it is not intended to completely replace these consumer queue products. Instead, it offers more convenient data subscription services for scenarios where simple streaming data acquisition is needed.</p><p>Using the IoTDB Subscription Client to consume data has significant advantages in the following application scenarios:</p><ol><li><p><strong>Continuously obtaining the latest data</strong>: By using a subscription method, it is more real-time than scheduled queries, simpler to program applications, and has a lower system burden;</p></li><li><p><strong>Simplify data push to third-party systems</strong>: No need to develop data push components for different systems within IoTDB, data can be streamed within third-party systems, making it easier to send data to systems such as Flink, Kafka, DataX, Camel, MySQL, PG, etc.</p></li></ol><h2 id="_2-key-concepts" tabindex="-1"><a class="header-anchor" href="#_2-key-concepts"><span>2. Key Concepts</span></a></h2><p>The IoTDB Subscription Client encompasses three core concepts: Topic, Consumer, and Consumer Group. The specific relationships are illustrated in the diagram below:</p><div align="center"><img src="https://alioss.timecho.com/docs/img/Data-sub05.png" alt="" style="width:60%;"></div><ol><li><p><strong>Topic</strong>: Topic is the data space of IoTDB, represented by paths and time ranges (such as the full time range of root. * *). Consumers can subscribe to data on these topics (currently existing and future written). Unlike Kafka, IoTDB can create topics after data is stored, and the output format can be either Message or TsFile.</p></li><li><p><strong>Consumer</strong>: Consumer is an IoTDB subscription client is located, responsible for receiving and processing data published to specific topics. Consumers retrieve data from the queue and process it accordingly. There are two types of Consumers available in the IoTDB subscription client:</p></li></ol><ul><li><code>SubscriptionPullConsumer</code>, which corresponds to the pull consumption model in message queues, where user code needs to actively invoke data retrieval logic.</li><li><code>SubscriptionPushConsumer</code>, which corresponds to the push consumption model in message queues, where user code is triggered by newly arriving data events.</li></ul><ol start="3"><li><strong>Consumer Group</strong>: A Consumer Group is a collection of Consumers who share the same Consumer Group ID. The Consumer Group has the following characteristics:</li></ol><ul><li>Consumer Group and Consumer are in a one to many relationship. That is, there can be any number of consumers in a consumer group, but a consumer is not allowed to join multiple consumer groups simultaneously.</li><li>A Consumer Group can have different types of Consumers (<code>SubscriptionPullConsumer</code> and <code>SubscriptionPushConsumer</code>).</li><li>It is not necessary for all consumers in a Consumer Group to subscribe to the same topic.</li><li>When different Consumers in the same Consumer Group subscribe to the same Topic, each piece of data under that Topic will only be processed by one Consumer within the group, ensuring that data is not processed repeatedly.</li></ul><h2 id="_3-sql-statements" tabindex="-1"><a class="header-anchor" href="#_3-sql-statements"><span>3. SQL Statements</span></a></h2><h3 id="_3-1-topic-management" tabindex="-1"><a class="header-anchor" href="#_3-1-topic-management"><span>3.1 Topic Management</span></a></h3><p>IoTDB supports the creation, deletion, and viewing of Topics through SQL statements. The status changes of Topics are illustrated in the diagram below:</p><div align="center"><img src="https://alioss.timecho.com/docs/img/Data_sub_04.png" alt="" style="width:60%;"></div><h4 id="_3-1-1-create-topic" tabindex="-1"><a class="header-anchor" href="#_3-1-1-create-topic"><span>3.1.1 Create Topic</span></a></h4><p>The SQL statement is as follows:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">    CREATE TOPIC [IF NOT EXISTS] &lt;topicName&gt; </span>
<span class="line">    WITH (</span>
<span class="line">    [&lt;parameter&gt; = &lt;value&gt;,],</span>
<span class="line">    );</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>IF NOT EXISTS semantics</strong>: Used in creation operations to ensure that the create command is executed when the specified topic does not exist, preventing errors caused by attempting to create an existing topic.</p><p>Detailed explanation of each parameter is as follows:</p><table><thead><tr><th style="text-align:left;">Key</th><th style="text-align:left;">Required or Optional with Default</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>path</strong></td><td style="text-align:left;">optional: <code>root.**</code></td><td style="text-align:left;">The path of the time series data corresponding to the topic, representing a set of time series to be subscribed.</td></tr><tr><td style="text-align:left;"><strong>start-time</strong></td><td style="text-align:left;">optional: <code>MIN_VALUE</code></td><td style="text-align:left;">The start time (event time) of the time series data corresponding to the topic. Can be in ISO format, such as 2011-12-03T10:15:30 or 2011-12-03T10:15:30+01:00, or a long value representing a raw timestamp consistent with the database&#39;s timestamp precision. Supports the special value <code>now</code>, which means the creation time of the topic. When start-time is <code>now</code> and end-time is MAX_VALUE, it indicates that only real-time data is subscribed.</td></tr><tr><td style="text-align:left;"><strong>end-time</strong></td><td style="text-align:left;">optional: <code>MAX_VALUE</code></td><td style="text-align:left;">The end time (event time) of the time series data corresponding to the topic. Can be in ISO format, such as 2011-12-03T10:15:30 or 2011-12:03T10:15:30+01:00, or a long value representing a raw timestamp consistent with the database&#39;s timestamp precision. Supports the special value <code>now</code>, which means the creation time of the topic. When end-time is <code>now</code> and start-time is MIN_VALUE, it indicates that only historical data is subscribed.</td></tr><tr><td style="text-align:left;"><strong>processor</strong></td><td style="text-align:left;">optional: <code>do-nothing-processor</code></td><td style="text-align:left;">The name and parameter configuration of the processor plugin, representing the custom processing logic applied to the original subscribed data, which can be specified in a similar way to pipe processor plugins.</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><strong>format</strong></td><td style="text-align:left;">optional: <code>SessionDataSetsHandler</code></td><td style="text-align:left;">Represents the form in which data is subscribed from the topic. Currently supports the following two forms of data: <code>SessionDataSetsHandler</code>: Data subscribed from the topic is obtained using <code>SubscriptionSessionDataSetsHandler</code>, and consumers can consume each piece of data row by row. <code>TsFileHandler</code>: Data subscribed from the topic is obtained using <code>SubscriptionTsFileHandler</code>, and consumers can directly subscribe to the TsFile storing the corresponding data.</td></tr><tr><td style="text-align:left;"><strong>mode</strong> <strong>(supported in versions 1.3.3.2 and later)</strong></td><td style="text-align:left;">option: <code>live</code></td><td style="text-align:left;">The subscription mode corresponding to the topic, with two options: <code>live</code>: When subscribing to this topic, the subscribed dataset mode is a dynamic dataset, which means that you can continuously consume the latest data. <code>snapshot</code>: When the consumer subscribes to this topic, the subscribed dataset mode is a static dataset, which means the snapshot of the data at the moment the consumer group subscribes to the topic (not the moment the topic is created); the formed static dataset after subscription does not support TTL.</td></tr><tr><td style="text-align:left;"><strong>loose-range</strong> <strong>(supported in versions 1.3.3.2 and later)</strong></td><td style="text-align:left;">option: <code>&quot;&quot;</code></td><td style="text-align:left;">String: Whether to strictly filter the data corresponding to this topic according to the path and time range, for example: &quot;&quot;: Strictly filter the data corresponding to this topic according to the path and time range. <code>&quot;time&quot;</code>: Do not strictly filter the data corresponding to this topic according to the time range (rough filter); strictly filter the data corresponding to this topic according to the path. <code>&quot;path&quot;</code>: Do not strictly filter the data corresponding to this topic according to the path (rough filter); strictly filter the data corresponding to this topic according to the time range. <code>&quot;time, path&quot;</code> / <code>&quot;path, time&quot;</code> / <code>&quot;all&quot;</code>: Do not strictly filter the data corresponding to this topic according to the path and time range (rough filter).</td></tr></tbody></table><p>Examples are as follows:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">-- Full subscription</span>
<span class="line">CREATE TOPIC root_all;</span>
<span class="line"></span>
<span class="line">-- Custom subscription</span>
<span class="line">CREATE TOPIC IF NOT EXISTS db_timerange</span>
<span class="line">WITH (</span>
<span class="line">  &#39;path&#39; = &#39;root.db.**&#39;,</span>
<span class="line">  &#39;start-time&#39; = &#39;2023-01-01&#39;,</span>
<span class="line">  &#39;end-time&#39; = &#39;2023-12-31&#39;,</span>
<span class="line">);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-1-2-delete-topic" tabindex="-1"><a class="header-anchor" href="#_3-1-2-delete-topic"><span>3.1.2 Delete Topic</span></a></h4><p>A Topic can only be deleted if it is not subscribed to. When a Topic is deleted, its related consumption progress will be cleared.</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">DROP TOPIC [IF EXISTS] &lt;topicName&gt;;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>IF EXISTS semantics</strong>: Used in deletion operations to ensure that the delete command is executed when a specified topic exists, preventing errors caused by attempting to delete non-existent topics.</p><h4 id="_3-1-3-view-topic" tabindex="-1"><a class="header-anchor" href="#_3-1-3-view-topic"><span>3.1.3 View Topic</span></a></h4><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">SHOW TOPICS;</span>
<span class="line">SHOW TOPIC &lt;topicName&gt;;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Result set:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">[TopicName|TopicConfigs]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>TopicName: Topic ID</li><li>TopicConfigs: Topic configurations</li></ul><h3 id="_3-2-check-subscription-status" tabindex="-1"><a class="header-anchor" href="#_3-2-check-subscription-status"><span>3.2 Check Subscription Status</span></a></h3><p>View all subscription relationships:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">-- Query the subscription relationships between all topics and consumer groups</span>
<span class="line">SHOW SUBSCRIPTIONS</span>
<span class="line">-- Query all subscriptions under a specific topic</span>
<span class="line">SHOW SUBSCRIPTIONS ON &lt;topicName&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Result set:</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">[TopicName|ConsumerGroupName|SubscribedConsumers]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>TopicName: The ID of the topic.</li><li>ConsumerGroupName: The ID of the consumer group specified in the user&#39;s code.</li><li>SubscribedConsumers: All client IDs in the consumer group that have subscribed to the topic.</li></ul><h2 id="_4-api-interface" tabindex="-1"><a class="header-anchor" href="#_4-api-interface"><span>4. API interface</span></a></h2>`,40)),l("p",null,[e[1]||(e[1]=s("In addition to SQL statements, IoTDB also supports using data subscription features through Java native interfaces（")),o(n,{to:"/UserGuide/latest/API/Programming-Java-Native-API.html"},{default:r(()=>e[0]||(e[0]=[s("link")])),_:1}),e[2]||(e[2]=s("）."))]),e[4]||(e[4]=t(`<h3 id="_4-1-topic-management" tabindex="-1"><a class="header-anchor" href="#_4-1-topic-management"><span>4.1 Topic Management</span></a></h3><p>The <code>SubscriptionSession</code> class in the IoTDB subscription client provides interfaces for topic management. The status changes of topics are illustrated in the diagram below:</p><div align="center"><img src="https://alioss.timecho.com/docs/img/Data_sub_04.png" alt="" style="width:60%;"></div><h4 id="_4-1-1-create-topic" tabindex="-1"><a class="header-anchor" href="#_4-1-1-create-topic"><span>4.1.1 Create Topic</span></a></h4><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line"> void createTopicIfNotExists(String topicName, Properties properties) throws Exception;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Example:</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">try (final SubscriptionSession session = new SubscriptionSession(host, port)) {</span>
<span class="line">  session.open();</span>
<span class="line">  final Properties config = new Properties();</span>
<span class="line">  config.put(TopicConstant.PATH_KEY, &quot;root.db.**&quot;);</span>
<span class="line">  session.createTopic(topicName, config);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-1-2-delete-topic" tabindex="-1"><a class="header-anchor" href="#_4-1-2-delete-topic"><span>4.1.2 Delete Topic</span></a></h4><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">void dropTopicIfExists(String topicName) throws Exception;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_4-1-3-view-topic" tabindex="-1"><a class="header-anchor" href="#_4-1-3-view-topic"><span>4.1.3 View Topic</span></a></h4><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">// Get all topics</span>
<span class="line">Set&lt;Topic&gt; getTopics() throws Exception;</span>
<span class="line"></span>
<span class="line">// Get a specific topic</span>
<span class="line">Optional&lt;Topic&gt; getTopic(String topicName) throws Exception;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-check-subscription-status" tabindex="-1"><a class="header-anchor" href="#_4-2-check-subscription-status"><span>4.2 Check Subscription Status</span></a></h3><p>The <code>SubscriptionSession</code> class in the IoTDB subscription client provides interfaces to check the subscription status:</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">Set&lt;Subscription&gt; getSubscriptions() throws Exception;</span>
<span class="line">Set&lt;Subscription&gt; getSubscriptions(final String topicName) throws Exception;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-3-create-consumer" tabindex="-1"><a class="header-anchor" href="#_4-3-create-consumer"><span>4.3 Create Consumer</span></a></h3><p>When creating a consumer using the JAVA native interface, you need to specify the parameters applied to the consumer.</p><p>For both <code>SubscriptionPullConsumer</code> and <code>SubscriptionPushConsumer</code>, the following common configurations are available:</p><table><thead><tr><th style="text-align:left;">key</th><th style="text-align:left;"><strong>required or optional with default</strong></th><th style="text-align:left;">description</th></tr></thead><tbody><tr><td style="text-align:left;">host</td><td style="text-align:left;">optional: 127.0.0.1</td><td style="text-align:left;"><code>String</code>: The RPC host of a certain DataNode in IoTDB</td></tr><tr><td style="text-align:left;">port</td><td style="text-align:left;">optional: 6667</td><td style="text-align:left;">Integer: The RPC port of a certain DataNode in IoTDB</td></tr><tr><td style="text-align:left;">node-urls</td><td style="text-align:left;">optional: 127.0.0.1:6667</td><td style="text-align:left;"><code>List&lt;String&gt;</code>: The RPC addresses of all DataNodes in IoTDB, can be multiple; either host:port or node-urls can be filled in. If both host:port and node-urls are filled in, the union of host:port and node-urls will be used to form a new node-urls application</td></tr><tr><td style="text-align:left;">username</td><td style="text-align:left;">optional: root</td><td style="text-align:left;"><code>String</code>: The username of a DataNode in IoTDB</td></tr><tr><td style="text-align:left;">password</td><td style="text-align:left;">optional: root</td><td style="text-align:left;"><code>String</code>: The password of a DataNode in IoTDB</td></tr><tr><td style="text-align:left;">groupId</td><td style="text-align:left;">optional</td><td style="text-align:left;"><code>String</code>: consumer group id, if not specified, a new consumer group will be randomly assigned, ensuring that different consumer groups have different consumer group ids</td></tr><tr><td style="text-align:left;">consumerId</td><td style="text-align:left;">optional</td><td style="text-align:left;"><code>String</code>: consumer client id, if not specified, it will be randomly assigned, ensuring that each consumer client id in the same consumer group is unique</td></tr><tr><td style="text-align:left;">heartbeatIntervalMs</td><td style="text-align:left;">optional: 30000 (min: 1000)</td><td style="text-align:left;"><code>Long</code>: The interval at which the consumer sends heartbeat requests to the IoTDB DataNode</td></tr><tr><td style="text-align:left;">endpointsSyncIntervalMs</td><td style="text-align:left;">optional: 120000 (min: 5000)</td><td style="text-align:left;"><code>Long</code>: The interval at which the consumer detects the expansion and contraction of IoTDB cluster nodes and adjusts the subscription connection</td></tr><tr><td style="text-align:left;">fileSaveDir</td><td style="text-align:left;">optional: Paths.get(System.getProperty(&quot;user.dir&quot;), &quot;iotdb-subscription&quot;).toString()</td><td style="text-align:left;"><code>String</code>: The temporary directory path where the TsFile files subscribed by the consumer are stored</td></tr><tr><td style="text-align:left;">fileSaveFsync</td><td style="text-align:left;">optional: false</td><td style="text-align:left;"><code>Boolean</code>: Whether the consumer actively calls fsync during the subscription of TsFile</td></tr></tbody></table><h4 id="_4-3-1-subscriptionpushconsumer" tabindex="-1"><a class="header-anchor" href="#_4-3-1-subscriptionpushconsumer"><span>4.3.1 SubscriptionPushConsumer</span></a></h4><p>The following are special configurations for <code>SubscriptionPushConsumer</code>:</p><table><thead><tr><th style="text-align:left;">key</th><th style="text-align:left;"><strong>required or optional with default</strong></th><th style="text-align:left;">description</th></tr></thead><tbody><tr><td style="text-align:left;">ackStrategy</td><td style="text-align:left;">optional: <code>ACKStrategy.AFTER_CONSUME</code></td><td style="text-align:left;">Consumption progress confirmation mechanism includes the following options: <code>ACKStrategy.BEFORE_CONSUME</code> (submit consumption progress immediately when the consumer receives data, before <code>onReceive</code>) <code>ACKStrategy.AFTER_CONSUME</code> (submit consumption progress after the consumer has consumed the data, after <code>onReceive</code>)</td></tr><tr><td style="text-align:left;">consumeListener</td><td style="text-align:left;">optional</td><td style="text-align:left;">Consumption data callback function, need to implement the <code>ConsumeListener</code> interface, define the consumption logic of <code>SessionDataSetsHandler</code> and <code>TsFileHandler</code> form data</td></tr><tr><td style="text-align:left;">autoPollIntervalMs</td><td style="text-align:left;">optional: 5000 (min: 500)</td><td style="text-align:left;">Long: The interval at which the consumer automatically pulls data, in ms</td></tr><tr><td style="text-align:left;">autoPollTimeoutMs</td><td style="text-align:left;">optional: 10000 (min: 1000)</td><td style="text-align:left;">Long: The timeout time for the consumer to pull data each time, in ms</td></tr></tbody></table><p>Among them, the ConsumerListener interface is defined as follows:</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">@FunctionInterface</span>
<span class="line">interface ConsumeListener {</span>
<span class="line">  default ConsumeResult onReceive(Message message) {</span>
<span class="line">    return ConsumeResult.SUCCESS;</span>
<span class="line">  }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">enum ConsumeResult {</span>
<span class="line">  SUCCESS,</span>
<span class="line">  FAILURE,</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-3-2-subscriptionpullconsumer" tabindex="-1"><a class="header-anchor" href="#_4-3-2-subscriptionpullconsumer"><span>4.3.2 SubscriptionPullConsumer</span></a></h4><p>The following are special configurations for <code>SubscriptionPullConsumer</code> :</p><table><thead><tr><th style="text-align:left;">key</th><th style="text-align:left;"><strong>required or optional with default</strong></th><th style="text-align:left;">description</th></tr></thead><tbody><tr><td style="text-align:left;">autoCommit</td><td style="text-align:left;">optional: true</td><td style="text-align:left;">Boolean: Whether to automatically commit consumption progress. If this parameter is set to false, the commit method must be called to manually <code>commit</code> consumption progress.</td></tr><tr><td style="text-align:left;">autoCommitInterval</td><td style="text-align:left;">optional: 5000 (min: 500)</td><td style="text-align:left;">Long: The interval at which consumption progress is automatically committed, in milliseconds. This only takes effect when the autoCommit parameter is true.</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr></tbody></table><p>After creating a consumer, you need to manually call the consumer&#39;s open method:</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">void open() throws Exception;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>At this point, the IoTDB subscription client will verify the correctness of the consumer&#39;s configuration. After a successful verification, the consumer will join the corresponding consumer group. That is, only after opening the consumer can you use the returned consumer object to subscribe to topics, consume data, and perform other operations.</p><h3 id="_4-4-subscribe-to-topics" tabindex="-1"><a class="header-anchor" href="#_4-4-subscribe-to-topics"><span>4.4 Subscribe to Topics</span></a></h3><p>Both <code>SubscriptionPushConsumer</code> and <code>SubscriptionPullConsumer</code> provide the following JAVA native interfaces for subscribing to topics:</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">// Subscribe to topics</span>
<span class="line">void subscribe(String topic) throws Exception;</span>
<span class="line">void subscribe(List&lt;String&gt; topics) throws Exception;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>Before a consumer subscribes to a topic, the topic must have been created, otherwise, the subscription will fail.</p></li><li><p>If a consumer subscribes to a topic that it has already subscribed to, no error will occur.</p></li><li><p>If there are other consumers in the same consumer group that have subscribed to the same topics, the consumer will reuse the corresponding consumption progress.</p></li></ul><h3 id="_4-5-consume-data" tabindex="-1"><a class="header-anchor" href="#_4-5-consume-data"><span>4.5 Consume Data</span></a></h3><p>For both push and pull mode consumers:</p><ul><li><p>Only after explicitly subscribing to a topic will the consumer receive data for that topic.</p></li><li><p>If no topics are subscribed to after creation, the consumer will not be able to consume any data, even if other consumers in the same consumer group have subscribed to some topics.</p></li></ul><h4 id="_4-5-1-subscriptionpushconsumer" tabindex="-1"><a class="header-anchor" href="#_4-5-1-subscriptionpushconsumer"><span>4.5.1 SubscriptionPushConsumer</span></a></h4><p>After <code>SubscriptionPushConsumer</code> subscribes to topics, there is no need to manually pull data.</p><p>The data consumption logic is within the <code>consumeListener</code> configuration specified when creating <code>SubscriptionPushConsumer</code>.</p><h4 id="_4-5-2-subscriptionpullconsumer" tabindex="-1"><a class="header-anchor" href="#_4-5-2-subscriptionpullconsumer"><span>4.5.2 SubscriptionPullConsumer</span></a></h4><p>After SubscriptionPullConsumer subscribes to topics, it needs to actively call the poll method to pull data:</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">List&lt;SubscriptionMessage&gt; poll(final Duration timeout) throws Exception;</span>
<span class="line">List&lt;SubscriptionMessage&gt; poll(final long timeoutMs) throws Exception;</span>
<span class="line">List&lt;SubscriptionMessage&gt; poll(final Set&lt;String&gt; topicNames, final Duration timeout) throws Exception;</span>
<span class="line">List&lt;SubscriptionMessage&gt; poll(final Set&lt;String&gt; topicNames, final long timeoutMs) throws Exception;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the poll method, you can specify the topic names to be pulled (if not specified, it defaults to pulling all topics that the consumer has subscribed to) and the timeout period.</p><p>When the SubscriptionPullConsumer is configured with the autoCommit parameter set to false, it is necessary to manually call the commitSync and commitAsync methods to synchronously or asynchronously commit the consumption progress of a batch of data:</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">void commitSync(final SubscriptionMessage message) throws Exception;</span>
<span class="line">void commitSync(final Iterable&lt;SubscriptionMessage&gt; messages) throws Exception;</span>
<span class="line"></span>
<span class="line">CompletableFuture&lt;Void&gt; commitAsync(final SubscriptionMessage message);</span>
<span class="line">CompletableFuture&lt;Void&gt; commitAsync(final Iterable&lt;SubscriptionMessage&gt; messages);</span>
<span class="line">void commitAsync(final SubscriptionMessage message, final AsyncCommitCallback callback);</span>
<span class="line">void commitAsync(final Iterable&lt;SubscriptionMessage&gt; messages, final AsyncCommitCallback callback);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The AsyncCommitCallback class is defined as follows:</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">public interface AsyncCommitCallback {</span>
<span class="line">  default void onComplete() {</span>
<span class="line">    // Do nothing</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  default void onFailure(final Throwable e) {</span>
<span class="line">    // Do nothing</span>
<span class="line">  }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-6-unsubscribe" tabindex="-1"><a class="header-anchor" href="#_4-6-unsubscribe"><span>4.6 Unsubscribe</span></a></h3><p>The <code>SubscriptionPushConsumer</code> and <code>SubscriptionPullConsumer</code> provide the following JAVA native interfaces for unsubscribing and closing the consumer:</p><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">// Unsubscribe from topics</span>
<span class="line">void unsubscribe(String topic) throws Exception;</span>
<span class="line">void unsubscribe(List&lt;String&gt; topics) throws Exception;</span>
<span class="line"></span>
<span class="line">// Close consumer</span>
<span class="line">void close();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>If a consumer unsubscribes from a topic that it has not subscribed to, no error will occur.</li><li>When a consumer is closed, it will exit the corresponding consumer group and automatically unsubscribe from all topics it is currently subscribed to.</li><li>Once a consumer is closed, its lifecycle ends, and it cannot be reopened to subscribe to and consume data again.</li></ul><h3 id="_4-7-code-examples" tabindex="-1"><a class="header-anchor" href="#_4-7-code-examples"><span>4.7 Code Examples</span></a></h3><h4 id="_4-7-1-single-pull-consumer-consuming-sessiondatasetshandler-format-data" tabindex="-1"><a class="header-anchor" href="#_4-7-1-single-pull-consumer-consuming-sessiondatasetshandler-format-data"><span>4.7.1 Single Pull Consumer Consuming SessionDataSetsHandler Format Data</span></a></h4><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">// Create topics</span>
<span class="line">try (final SubscriptionSession session = new SubscriptionSession(HOST, PORT)) {</span>
<span class="line">  session.open();</span>
<span class="line">  final Properties config = new Properties();</span>
<span class="line">  config.put(TopicConstant.PATH_KEY, &quot;root.db.**&quot;);</span>
<span class="line">  session.createTopic(TOPIC_1, config);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// Subscription: property-style ctor</span>
<span class="line">final Properties config = new Properties();</span>
<span class="line">config.put(ConsumerConstant.CONSUMER_ID_KEY, &quot;c1&quot;);</span>
<span class="line">config.put(ConsumerConstant.CONSUMER_GROUP_ID_KEY, &quot;cg1&quot;);</span>
<span class="line"></span>
<span class="line">final SubscriptionPullConsumer consumer1 = new SubscriptionPullConsumer(config);</span>
<span class="line">consumer1.open();</span>
<span class="line">consumer1.subscribe(TOPIC_1);</span>
<span class="line">while (true) {</span>
<span class="line">  LockSupport.parkNanos(SLEEP_NS); // wait some time</span>
<span class="line">  final List&lt;SubscriptionMessage&gt; messages = consumer1.poll(POLL_TIMEOUT_MS);</span>
<span class="line">  for (final SubscriptionMessage message : messages) {</span>
<span class="line">    for (final SubscriptionSessionDataSet dataSet : message.getSessionDataSetsHandler()) {</span>
<span class="line">      System.out.println(dataSet.getColumnNames());</span>
<span class="line">      System.out.println(dataSet.getColumnTypes());</span>
<span class="line">      while (dataSet.hasNext()) {</span>
<span class="line">        System.out.println(dataSet.next());</span>
<span class="line">      }</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">  // Auto commit</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// Show topics and subscriptions</span>
<span class="line">try (final SubscriptionSession session = new SubscriptionSession(HOST, PORT)) {</span>
<span class="line">  session.open();</span>
<span class="line">  session.getTopics().forEach((System.out::println));</span>
<span class="line">  session.getSubscriptions().forEach((System.out::println));</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">consumer1.unsubscribe(TOPIC_1);</span>
<span class="line">consumer1.close();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-7-2-multiple-push-consumers-consuming-tsfilehandler-format-data" tabindex="-1"><a class="header-anchor" href="#_4-7-2-multiple-push-consumers-consuming-tsfilehandler-format-data"><span>4.7.2 Multiple Push Consumers Consuming TsFileHandler Format Data</span></a></h4><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">// Create topics</span>
<span class="line">try (final SubscriptionSession subscriptionSession = new SubscriptionSession(HOST, PORT)) {</span>
<span class="line">  subscriptionSession.open();</span>
<span class="line">  final Properties config = new Properties();</span>
<span class="line">  config.put(TopicConstant.FORMAT_KEY, TopicConstant.FORMAT_TS_FILE_HANDLER_VALUE);</span>
<span class="line">  subscriptionSession.createTopic(TOPIC_2, config);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">final List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();</span>
<span class="line">for (int i = 0; i &lt; 8; ++i) {</span>
<span class="line">  final int idx = i;</span>
<span class="line">  final Thread thread =</span>
<span class="line">      new Thread(</span>
<span class="line">          () -&gt; {</span>
<span class="line">            // Subscription: builder-style ctor</span>
<span class="line">            try (final SubscriptionPushConsumer consumer2 =</span>
<span class="line">                new SubscriptionPushConsumer.Builder()</span>
<span class="line">                    .consumerId(&quot;c&quot; + idx)</span>
<span class="line">                    .consumerGroupId(&quot;cg2&quot;)</span>
<span class="line">                    .fileSaveDir(System.getProperty(&quot;java.io.tmpdir&quot;))</span>
<span class="line">                    .ackStrategy(AckStrategy.AFTER_CONSUME)</span>
<span class="line">                    .consumeListener(</span>
<span class="line">                        message -&gt; {</span>
<span class="line">                          doSomething(message.getTsFileHandler());</span>
<span class="line">                          return ConsumeResult.SUCCESS;</span>
<span class="line">                        })</span>
<span class="line">                    .buildPushConsumer()) {</span>
<span class="line">              consumer2.open();</span>
<span class="line">              consumer2.subscribe(TOPIC_2);</span>
<span class="line">            } catch (final IOException e) {</span>
<span class="line">              throw new RuntimeException(e);</span>
<span class="line">            }</span>
<span class="line">          });</span>
<span class="line">  thread.start();</span>
<span class="line">  threads.add(thread);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">for (final Thread thread : threads) {</span>
<span class="line">  thread.join();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-frequently-asked-questions" tabindex="-1"><a class="header-anchor" href="#_5-frequently-asked-questions"><span>5. Frequently Asked Questions</span></a></h2><h3 id="_5-1-what-is-the-difference-between-iotdb-data-subscription-and-kafka" tabindex="-1"><a class="header-anchor" href="#_5-1-what-is-the-difference-between-iotdb-data-subscription-and-kafka"><span>5.1 What is the difference between IoTDB data subscription and Kafka?</span></a></h3><ol><li>Consumption Orderliness</li></ol><ul><li><strong>Kafka guarantees that messages within a single partition are ordered</strong>，when a topic corresponds to only one partition and only one consumer subscribes to this topic, the order in which the consumer (single-threaded) consumes the topic data is the same as the order in which the data is written.</li><li>The IoTDB subscription client <strong>does not guarantee</strong> that the order in which the consumer consumes the data is the same as the order in which the data is written, but it will try to reflect the order of data writing.</li></ul><ol start="2"><li>Message Delivery Semantics</li></ol><ul><li>Kafka can achieve Exactly once semantics for both Producers and Consumers through configuration.</li><li>The IoTDB subscription client currently cannot provide Exactly once semantics for Consumers.</li></ul>`,62))])}const b=i(p,[["render",u],["__file","Data-subscription.html.vue"]]),g=JSON.parse('{"path":"/UserGuide/latest/User-Manual/Data-subscription.html","title":"Data Subscription","lang":"en-US","frontmatter":{"description":"Data Subscription 1. Feature Introduction The IoTDB data subscription module (also known as the IoTDB subscription client) is a feature supported after IoTDB V1.3.3, which provi...","head":[["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://iotdb.apache.org/zh/UserGuide/latest/User-Manual/Data-subscription.html"}],["meta",{"property":"og:url","content":"https://iotdb.apache.org/UserGuide/latest/User-Manual/Data-subscription.html"}],["meta",{"property":"og:site_name","content":"IoTDB Website"}],["meta",{"property":"og:title","content":"Data Subscription"}],["meta",{"property":"og:description","content":"Data Subscription 1. Feature Introduction The IoTDB data subscription module (also known as the IoTDB subscription client) is a feature supported after IoTDB V1.3.3, which provi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-18T12:49:29.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-18T12:49:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Data Subscription\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-18T12:49:29.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1.  Feature Introduction","slug":"_1-feature-introduction","link":"#_1-feature-introduction","children":[]},{"level":2,"title":"2. Key Concepts","slug":"_2-key-concepts","link":"#_2-key-concepts","children":[]},{"level":2,"title":"3. SQL Statements","slug":"_3-sql-statements","link":"#_3-sql-statements","children":[{"level":3,"title":"3.1 Topic Management","slug":"_3-1-topic-management","link":"#_3-1-topic-management","children":[]},{"level":3,"title":"3.2 Check Subscription Status","slug":"_3-2-check-subscription-status","link":"#_3-2-check-subscription-status","children":[]}]},{"level":2,"title":"4. API interface","slug":"_4-api-interface","link":"#_4-api-interface","children":[{"level":3,"title":"4.1 Topic Management","slug":"_4-1-topic-management","link":"#_4-1-topic-management","children":[]},{"level":3,"title":"4.2 Check Subscription Status","slug":"_4-2-check-subscription-status","link":"#_4-2-check-subscription-status","children":[]},{"level":3,"title":"4.3 Create Consumer","slug":"_4-3-create-consumer","link":"#_4-3-create-consumer","children":[]},{"level":3,"title":"4.4 Subscribe to Topics","slug":"_4-4-subscribe-to-topics","link":"#_4-4-subscribe-to-topics","children":[]},{"level":3,"title":"4.5 Consume Data","slug":"_4-5-consume-data","link":"#_4-5-consume-data","children":[]},{"level":3,"title":"4.6 Unsubscribe","slug":"_4-6-unsubscribe","link":"#_4-6-unsubscribe","children":[]},{"level":3,"title":"4.7 Code Examples","slug":"_4-7-code-examples","link":"#_4-7-code-examples","children":[]}]},{"level":2,"title":"5. Frequently Asked Questions","slug":"_5-frequently-asked-questions","link":"#_5-frequently-asked-questions","children":[{"level":3,"title":"5.1 What is the difference between IoTDB data subscription and Kafka?","slug":"_5-1-what-is-the-difference-between-iotdb-data-subscription-and-kafka","link":"#_5-1-what-is-the-difference-between-iotdb-data-subscription-and-kafka","children":[]}]}],"git":{"createdTime":1731401826000,"updatedTime":1731934169000,"contributors":[{"name":"W1y1r","email":"150988475+W1y1r@users.noreply.github.com","commits":2}]},"readingTime":{"minutes":9.55,"words":2865},"filePathRelative":"UserGuide/latest/User-Manual/Data-subscription.md","localizedDate":"November 12, 2024","autoDesc":true}');export{b as comp,g as data};
